[TOC]



# 1.知识点

## 1.1 概念相关

### 1.1.1 **String属于基础的数据类型吗？**

不属于，String是java定义的一个最终类。

### 1.1.2 **String类可以被继承吗？**

String类在声明时使用final关键字修饰，被final关键字修饰的类无法被继承。

接下来我们可以看一下String类的源代码片段：

```java
public final class String
    implements java.io.Serializable, Comparable<String>,CharSequence {
    /** The value is used for character storage. */
    private final char value[];

    /** Cache the hash code for the string */
    private int hash; // Default to 0

    /** use serialVersionUID from JDK 1.0.2 for interoperability */
    private static final long serialVersionUID = -6849794470754667710L;
```

**为什么Java语言的开发者，把String类定义为final的呢？**

- 因为只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。
- 因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。
- 因为字符串是不可变的，所以在它创建的时候HashCode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。



### 1.1.2 **Java的四种引用，强弱软虚，用到的场景**

1. 强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象
2. 软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。
3. 弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象
4. 虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。

### 1.1.3 谈谈你对解析与分派的认识?

##### 解析

指方法在运行前，即编译期间就可知的，有一个确定的版本，运行期间也不会改变。解析是静态的，在类加载的解析阶段就可将符号引用转变成直接引用。

##### 分派

可分为静态分派和动态分派，重载属于静态分派，覆盖属于动态分派。
静态分派是指在重载时通过参数的静态类型而非实际类型作为判断依据，在编译阶段，编译器可根据参数的静态类型决定使用哪一个重载版本。
动态分派则需要根据实际类型来调用相应的方法。

### 1.1.4 Java中实现多态的机制是什么？

多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时不确定，在运行期间才确定，一个引用变量到底会指向哪个类的实例。这样就可以不用修改源程序，就可以让引用变量绑定到各种不同的类实现上。

Java实现多态有三个必要条件：继承、重定、向上转型，在多态中需要将子类的引用赋值给父类对象，只有这样该引用才能够具备调用父类方法和子类的方法。

### 1.1.5 说说你对Java注解的理解

解是通过@interface关键字来进行定义的，形式和接口差不多，只是前面多了一个@

```java
public @interface TestAnnotation {

}
```

使用时`@TestAnnotation`来引用，要使注解能正常工作，还需要使用元注解，它是可以注解到注解上的注解。元标签有`@Retention @Documented @Target @Inherited @Repeatable`五种

`@Retention`说明注解的存活时间，取值有`RetentionPolicy.SOURCE` 注解只在源码阶段保留，在编译器进行编译时被丢弃；`RetentionPolicy.CLASS` 注解只保留到编译进行的时候，并不会被加载到JVM中。`RetentionPolicy.RUNTIME`可以留到程序运行的时候，它会被加载进入到JVM中，所以在程序运行时可以获取到它们。

`@Documented `注解中的元素包含到`javadoc`中去

`@Target `限定注解的应用场景，`ElementType.FIELD`给属性进行注解；`ElementType.LOCAL_VARIABLE`可以给局部变量进行注解；`ElementType.METHOD`可以给方法进行注解；`ElementType.PACKAGE`可以给一个包进行注解 `ElementType.TYPE`可以给一个类型进行注解，如类、接口、枚举

`@Inherited `若一个超类被@Inherited注解过的注解进行注解，它的子类没有被任何注解应用的话，该子类就可继承超类的注解；

##### 注解的作用：

1. 提供信息给编译器：编译器可利用注解来探测错误和警告信息
2. 编译阶段：软件工具可以利用注解信息来生成代码、html文档或做其它相应处理；
3. 运行阶段：程序运行时可利用注解提取代码

注解是通过反射获取的，可以通过Class对象的isAnnotationPresent()方法判断它是否应用了某个注解，再通过getAnnotation()方法获取Annotation对象



## 1.2 基本类型

### 1.2.1 **char 型变量中能不能存储一个中文汉字，为什么？**

char 类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char 类型占2个字节（16 比特），所以放一个中文是没问题的。

 

补充：使用Unicode 意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是 Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如 InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务。

### 1.2.2 **loat f=3.4;是否正确？**

答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。

### 1.2.3 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？

答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。





## 1.3 关键字

### 1.3.1 **讲讲对static的理解？**

**Java中是否可以覆盖一个private或者是static的方法？**

如果一个类的变量或者方法前面有static修饰，那么表明这个方法或者变量属于这个类，也就是说可以在不创建对象的情况下直接使用.

当父类的方法被private修饰时，表明该方法为父类私有，对其他任何类都是不可见的，因此如果子类定了一个与父类一样的方法，这对于子类来说相当于是一个新的私有方法，且如果要进行向上转型，然后去调用该“覆盖方法”，会产生编译错误

static方法时编译时静态绑定的，属于类，而覆盖是运行时动态绑定的(动态绑定的多态),因此不能覆盖.

### 1.3.2 **是否可以在static环境中访问非static变量？**

static变量在Java中是属于类的，它在所有的实例中的值是一样的。

当类被Java虚拟机载入的时候，会对static变量进行初始化。

如果代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。



## 1.4 运算

### 1.4.1 **==和equals的区别**

==比较的是对象在内存中的地址值

equals比较的是两个对象是否相等，在不重写equals方法的情况下，默认是和==的作用一样。

### 1.4.2 **什么是值传递和引用传递？Java中是值传递还是引用传递，还是都有?**

1. 值传递：就是在方法调用的时候，实参是将自己的一份拷贝赋给形参，在方法内，对该参数值的修改不影响原来实参。

2. 引用传递：是在方法调用的时候，实参将自己的地址传递给形参，此时方法内对该参数值的改变，就是对该实参的实际操作。

在java中只有一种传递方式，那就是值传递.可能比较让人迷惑的就是java中的对象传递时，对形参的改变依然会影响到该对象的内容。

Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的内存地址。这个值（内存地址）被传递后，同一个内存地址指向堆内存当中的同一个对象，所以通过哪个引用去操作这个对象，对象的属性都是改变的。

### 1.4.3 **&和&&的区别？**

虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &&!username.equals(“”)，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。

### 1.4.4 **Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？**

答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。

### 1.4.5 **switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？**

expr可以是byte、short、char、int、enum、String类型，但是long类型不能

### 1.4.6 **用最有效率的方法计算2乘以8？**

答： 2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。

### 1.4.7 String s = new String(“xyz”);创建了几个字符串对象？

答：一个或者两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。

### java中的++操作符线程安全么?

不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。













## 1.1 面向对象和面向过程的区别

**面向过程**

优点： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix 等一般采用面向过程开发，性能是最重要的因素。

缺点： 没有面向对象易维护、易复用、易扩展

**面向对象**

优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护

缺点： 性能比面向过程低

## 1.2 Java 语言有哪些特点

1. 简单易学；
2. 面向对象（封装，继承，多态）；
3. 平台无关性（ Java 虚拟机实现平台无关性）；
4. 可靠性；
5. 安全性；
6. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；7. 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；
8. 编译与解释并存；

## 1.3 关于 JVM JDK 和 JRE 最详细通俗的解答

 ### 1.3.1 JVM

Java 虚拟机（ JVM）是运行 Java 字节码的虚拟机。 JVM 有针对不同系统的特 定实现（ Windows， Linux， macOS），目的是使用相同的字节码，它们都会给 出相同的结果。

 什么是字节码?采用字节码的好处是什么?

 在 Java 中， JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。 Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此， Java 程序无须重新编译便可在多种不同的计算机上运行。

### 1.3.2  Java 程序从源代码到运行一般有下面 3 步：

 我们需要格外注意的是 .class->机器码 这一步。在这一步 jvm 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的，也就是所谓的热点代 码，所以后面引进了 JIT 编译器， JIT 属于运行时编译。当 JIT 编译器完成第 一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什 么经常会说 Java 是编译与解释共存的语言。HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译 的部分。 JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。 JDK 9 引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。 JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。

总结： Java 虚拟机（ JVM）是运行 Java 字节码的虚拟机。 JVM 有针对不同系统的特定实现（ Windows， Linux， macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。

## 1.4 JDK 和 JRE

JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（ javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

 JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（ JVM）， Java 类库， java 命令和其他的一些基础构件。但是，它不能用于创建新程序。

如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。

如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，

您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译servlet。

## 1.5 字符型常量和字符串常量的区别

1. 形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符
2. 含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)
3. 占内存大小 字符常量只占 2 个字节 字符串常量占若干个字节(至少一个字符结束标志) (注意： char 在 Java 中占两个字节)
## 1.6 构造器 Constructor 是否可被 override
  在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor 也就不能被 override（重写） ,但是可以 overload（重载） ,所以你可以看到一个类中有多个构造函数的情况。
## 1.8 重载和重写的区别

重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。

重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。

## 1.9  Java 面向对象编程三大特性: 封装 继承 多态

**封装**

 封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

**继承**

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。
关于继承如下 3 点请记住：

1. 子类拥有父类非 private 的属性和方法。

2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。

3. 子类可以用自己的方式实现父类的方法。（以后介绍）。

**多态**

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

## 1.10 String StringBuffer 和 StringBuilder 的区别

String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、 append、 insert、 indexOf 等公共方法。 StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

性能

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。 StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用
StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。
对于三者使用的总结：

1. 操作少量的数据 = String
2. 单线程操作字符串缓冲区下操作大量数据 = StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据 = StringBuffer

## 1.11 自动装箱与拆箱

  装箱：将基本类型用它们对应的引用类型包装起来；
  拆箱：将包装类型转换为基本数据类型；
## 1.12 在一个静态方法内调用一个非静态成员为什么是非法的

由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

## 1.13 import java 和 javax 有什么区别

刚开始的时候 JavaAPI 所必需的包是 java 开头的包， javax 当时只是扩展API 包来说使用。然而随着时间的推移， javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏
一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。所以，实际上 java 和 javax 没有区别。这都是一个名字。

## 1.14 接口和抽象类的区别是什么

1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法

2. 接口中的实例变量默认是 final 类型的，而抽象类中则不一定
3. 一个类可以实现多个接口，但最多只能实现一个抽象类
4. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定
5. 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

## 1.15 成员变量与局部变量的区别有那些

14. 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员
   变量和局部变量都能被 final 所修饰；
2. 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存
3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。

## 1.16 == 与 equals(重要)

```
== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。 (基本数据类型==比较的是值，
		 引用数据类型==比较的是内存地址)
equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
	情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
	情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，
	       则返回 true (即，认为这两个对象相等)。
```

举个例子

```java
public class test1 {
  public static void main(String[] args) {
    String a = new String("ab"); // a 为一个引用
    String b = new String("ab"); // b 为另一个引用,对象的内容一样
    String aa = "ab"; // 放在常量池中
    String bb = "ab"; // 从常量池中查找
    if (aa == bb) // true
      System.out.println("aa==bb");
    if (a == b) // false，非同一对象
      System.out.println("a==b");
    if (a.equals(b)) // true
      System.out.println("aEQb");
    if (42 == 42.0) { // true
      System.out.println("true");
    }
  }
}
```

说明：

1. String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
2. 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象

## 1.17 hashCode 与 equals（重要）

面试官可能会问你： “你重写过 hashcode 和 equals 么，为什么重写 equals时必须重写 hashCode 方法？ ”

### 1.17.1 hashCode（）介绍

hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

**为什么要有 hashCode?**

我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：当你把对象加入 HashSet 时， HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如
果没有相符的 hashcode， HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同， HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。

hashCode（）与 equals（）的相关规定

1. 如果两个对象相等，则 hashcode 一定也是相同的
2. 两个对象相等,对两个对象分别调用 equals 方法都返回 true
3. 两个对象有相同的 hashcode 值，它们也不一定是相等的
4. 因此， equals 方法被覆盖过，则 hashCode 方法也必须被覆盖
5. hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）



## 1.18 关于 final 关键字的一些总结
final 关键字主要用在三个地方：变量、方法、类。

1. 对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

2. 当用 final 修饰一个类时，表明这个类不能被继承。 final 类中的所有成员方法都会被隐式地指定为 final 方法。

3. 使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用
  带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。


## 1.19 Java 序列化中如果有些字段不想进行序列化 怎么办?

 对于不想进行序列化的变量，使用 transient 关键字修饰。
 transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；
 当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。
 transient 只能修饰变量，不能修饰类和方法。

## 1.20 **HashMap 与 Hashtable 的区别**

1.  历史原因: Hashtable继承Dictonary类, HashMap继承自abstractMap
2.  HashMap允许空的键值对, 但最多只有一个空对象，而HashTable不允许。
3. HashTable同步，而HashMap非同步，效率上比HashTable要高

##### 1.21 **Java 中 WeakReference 与 SoftReference的区别？**

Java中一共有四种类型的引用。StrongReference、 SoftReference、 WeakReference 以及 PhantomReference。

StrongReference 是 Java 的默认引用实现, 它会尽可能长时间的存活于 JVM 内，当没有任何对象指向它时将会被GC回收

WeakReference，顾名思义, 是一个弱引用, 当所引用的对象在

JVM 内不再有强引用时, 将被GC回收

虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得

SoftReference 非常适合缓存应用

#### 1.22 **进程间通信有哪几种方式？**

1. 管道（Pipe）
2. 命名管道（named pipe）
3. 信号（Signal）
4. 消息（Message）队列
5. 共享内存，
6. 内存映射（mapped memory）
7. 信号量（semaphore）
8. 套接口（Socket）

#### 1.23 String类能被继承吗，为什么？

不能，因为String 是final类型的。

### **为什么char数组比Java中的String更适合存储密码？**

字符串：1)由于字符串在Java中是不可变的，如果你将密码存储为纯文本，它将在内存中可用，直到垃圾收集器清除它.并且为了可重用性，会存在String在字符串池中,它很可能会保留在内存中持续很长时间，从而构成安全威胁。

　　由于任何有权访问内存转储的人都可以以明文形式找到密码，这是另一个原因，你应该始终使用加密密码而不是纯文本。由于字符串是不可变的，所以不能更改字符串的内容，因为任何更改都会产生新的字符串，而如果你使用char[]，你就可以将所有元素设置为空白或零。因此，在字符数组中存储密码可以明显降低窃取密码的安全风险。

　　2)Java本身建议使用JPasswordField的getPassword()方法，该方法返回一个char[]和不推荐使用的getTex()方法，该方法以明文形式返回密码，由于安全原因。应遵循Java团队的建议,坚持标准而不是反对它。

　　3)使用String时，总是存在在日志文件或控制台中打印纯文本的风险，但如果使用Array，则不会打印数组的内容而是打印其内存位置。虽然不是一个真正的原因，但仍然有道理。

### **Integer内部缓存？**

Integer类内部有一个staitic 的Integer数组，存储的是一些已经完成初始化的Integer对象，一般值为（-128~127），若用==比较，则有时候会因为值不在缓存中而返回false，所以应该用equals比较。

### **Java有没有goto?**

java中的保留字，现在没有在java中使用。

### **构造器Constructor是否可被override?**

构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading。

### **写clone()方法时，通常都有一行代码，是什么？**

Clone 有缺省行为，super.clone();他负责产生正确大小的空间，并逐位复制。

### 问题：说明一下public static void main(String args[])这段声明里每个关键字的作用

答案：

public: main方法是Java程序运行时调用的第一个方法，因此它必须对Java环境可见。所以可见性设置为pulic.

static: Java平台调用这个方法时不会创建这个类的一个实例，因此这个方法必须声明为static。

void: main方法没有返回值。

String是命令行传进参数的类型，args是指命令行传进的字符串数组。

### **如果去掉了main方法的static修饰符会怎样？**

答案：程序能正常编译。运行时会抛NoSuchMethodError异常。

### **ResourceBundle类是什么?**

答案：ResourceBundle用来存储指定语言环境的资源，应用程序可以根据运行时的语言环境来加载这些资源，从而提供不同语言的展示。

### **在System.out.println()里面,System, out, println分别是什么?**

答案：System是系统提供的预定义的final类，out是一个PrintStream对象，println是out对象里面一个重载的方法。

### **数值提升是什么?**

答案：数值提升是指数据从一个较小的数据类型转换成为一个更大的数据类型，以便进行整型或者浮点型运算。在数值提升的过程中，byte,char,short值会被转化成int类型。需要的时候int类型也可能被提升成long。long和float则有可能会被转换成double类型。

#### **程序中可以允许多个类同时拥有都有main方法吗?**

答案：可以。当程序运行的时候，我们会指定运行的类名。JVM只会在你指定的类中查找main方法。因此多个类拥有main方法并不存在命名冲突的问题。

#### **不重写Bean的hashCode()方法是否会对性能带来影响？**

　　这个问题非常好，每个人可能都会有自己的体会。按照我掌握的知识来说，如果一个计算hash的方法写得不好，直接的影响是，当向HashMap中添加元素的时候会更频繁地造成冲突，因此最终增加了耗时。但是自从Java8开始，这种影响不再像前几个版本那样显著了，因为当冲突的发生超出了一定的限度之后，链表类的实现将会被替换成二叉树（binarytree）实现，这时你仍可以得到O(logN)的开销，优于链表类的O(n)。

### 什么是 Busy spin？我们为什么要使用它？

Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他 CPU 上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。

